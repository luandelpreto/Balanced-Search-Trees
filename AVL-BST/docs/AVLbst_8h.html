<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVL-BST: AVLbst.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AVL-BST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AVLbst.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa52776b46e8441e55968bf19ad2b503"><td class="memItemLeft" align="right" valign="top">AVL_bst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#aaa52776b46e8441e55968bf19ad2b503">AVL_create</a> (void)</td></tr>
<tr class="memdesc:aaa52776b46e8441e55968bf19ad2b503"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions returns a new AVL_bst on the heap.  <a href="#aaa52776b46e8441e55968bf19ad2b503">More...</a><br /></td></tr>
<tr class="separator:aaa52776b46e8441e55968bf19ad2b503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85948f4dd8cb66132a7ea19b71a9f59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#aa85948f4dd8cb66132a7ea19b71a9f59">AVL_init</a> (AVL_bst *restrict tree, AVL_compare compare, AVL_alloc alloc, AVL_free_node freenode, AVL_free_data freedata)</td></tr>
<tr class="memdesc:aa85948f4dd8cb66132a7ea19b71a9f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the AVL_bst attributes. Pass NULL to freedata if the allocations are done in stack, otherwise pass a free-like function.  <a href="#aa85948f4dd8cb66132a7ea19b71a9f59">More...</a><br /></td></tr>
<tr class="separator:aa85948f4dd8cb66132a7ea19b71a9f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4ea630e4b9a4319d047c3bf3c1cd38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#aef4ea630e4b9a4319d047c3bf3c1cd38">AVL_destroy</a> (AVL_bst **restrict tree)</td></tr>
<tr class="memdesc:aef4ea630e4b9a4319d047c3bf3c1cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys a AVL_bst allocated by AVL_create.  <a href="#aef4ea630e4b9a4319d047c3bf3c1cd38">More...</a><br /></td></tr>
<tr class="separator:aef4ea630e4b9a4319d047c3bf3c1cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871fe8673bf7f588a5f50406fab8316b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#a871fe8673bf7f588a5f50406fab8316b">AVL_clear</a> (AVL_bst *restrict tree)</td></tr>
<tr class="memdesc:a871fe8673bf7f588a5f50406fab8316b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function empties the parameter tree without freeing tree.  <a href="#a871fe8673bf7f588a5f50406fab8316b">More...</a><br /></td></tr>
<tr class="separator:a871fe8673bf7f588a5f50406fab8316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c933f22384e280483ff295fb709080"><td class="memItemLeft" align="right" valign="top">AVL_bst_node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#ab2c933f22384e280483ff295fb709080">AVL_find</a> (AVL_bst *restrict tree, const void *key)</td></tr>
<tr class="memdesc:ab2c933f22384e280483ff295fb709080"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for key in tree.  <a href="#ab2c933f22384e280483ff295fb709080">More...</a><br /></td></tr>
<tr class="separator:ab2c933f22384e280483ff295fb709080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab099c2a1c5b8706a24a2504775df1c7f"><td class="memItemLeft" align="right" valign="top">AVL_bst_node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#ab099c2a1c5b8706a24a2504775df1c7f">AVL_interval_find</a> (AVL_bst *restrict tree, const void *a, const void *b)</td></tr>
<tr class="memdesc:ab099c2a1c5b8706a24a2504775df1c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for a key interval [a, b[.  <a href="#ab099c2a1c5b8706a24a2504775df1c7f">More...</a><br /></td></tr>
<tr class="separator:ab099c2a1c5b8706a24a2504775df1c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecacbf39ee27a5d2d05f1b7e79d9f2eb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#aecacbf39ee27a5d2d05f1b7e79d9f2eb">AVL_get_data_from_node</a> (AVL_bst_node *node)</td></tr>
<tr class="memdesc:aecacbf39ee27a5d2d05f1b7e79d9f2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the data from a leaf node.  <a href="#aecacbf39ee27a5d2d05f1b7e79d9f2eb">More...</a><br /></td></tr>
<tr class="separator:aecacbf39ee27a5d2d05f1b7e79d9f2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8714e1bcc93e3d015f658da9248b6484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#a8714e1bcc93e3d015f658da9248b6484">AVL_process_node_list</a> (AVL_bst_node *nodelst, AVL_map mapfn)</td></tr>
<tr class="memdesc:a8714e1bcc93e3d015f658da9248b6484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that processes the node list created by AVL_interval_find.  <a href="#a8714e1bcc93e3d015f658da9248b6484">More...</a><br /></td></tr>
<tr class="separator:a8714e1bcc93e3d015f658da9248b6484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa569a0dc64e44f15db6b2d63e4084da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#aa569a0dc64e44f15db6b2d63e4084da3">AVL_clear_node_list</a> (AVL_bst *restrict tree, AVL_bst_node *nodelst)</td></tr>
<tr class="memdesc:aa569a0dc64e44f15db6b2d63e4084da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that empties the nodes list created by AVL_interval_find.  <a href="#aa569a0dc64e44f15db6b2d63e4084da3">More...</a><br /></td></tr>
<tr class="separator:aa569a0dc64e44f15db6b2d63e4084da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad467c47f10fee3e944603989095bb1b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#ad467c47f10fee3e944603989095bb1b0">AVL_insert</a> (AVL_bst *restrict tree, void *key, void *data)</td></tr>
<tr class="memdesc:ad467c47f10fee3e944603989095bb1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that inserts a new data with given key in the tree.  <a href="#ad467c47f10fee3e944603989095bb1b0">More...</a><br /></td></tr>
<tr class="separator:ad467c47f10fee3e944603989095bb1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b92bbf8fc48d0a3f0ab7611e3608f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#a77b92bbf8fc48d0a3f0ab7611e3608f7">AVL_delete</a> (AVL_bst *restrict tree, void *key, void **data)</td></tr>
<tr class="memdesc:a77b92bbf8fc48d0a3f0ab7611e3608f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that deletes the data with the given key in the tree.  <a href="#a77b92bbf8fc48d0a3f0ab7611e3608f7">More...</a><br /></td></tr>
<tr class="separator:a77b92bbf8fc48d0a3f0ab7611e3608f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12c4e1787742f360b9626a2c95f5722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AVLbst_8h.html#ae12c4e1787742f360b9626a2c95f5722">AVL_traverse_preorder</a> (AVL_bst *restrict tree, AVL_map mapfn)</td></tr>
<tr class="memdesc:ae12c4e1787742f360b9626a2c95f5722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function the traverses the tree applying mapfn function.  <a href="#ae12c4e1787742f360b9626a2c95f5722">More...</a><br /></td></tr>
<tr class="separator:ae12c4e1787742f360b9626a2c95f5722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a871fe8673bf7f588a5f50406fab8316b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871fe8673bf7f588a5f50406fab8316b">&#9670;&nbsp;</a></span>AVL_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_clear </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function empties the parameter tree without freeing tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the tree to be emptied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_FREE_NULLPTR_ERR</td><td>if the root of the tree is NULL </td></tr>
    <tr><td class="paramname">AVL_EMPTY_TREE_ERR</td><td>if the tree is already empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa569a0dc64e44f15db6b2d63e4084da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa569a0dc64e44f15db6b2d63e4084da3">&#9670;&nbsp;</a></span>AVL_clear_node_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL_clear_node_list </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_bst_node *&#160;</td>
          <td class="paramname"><em>nodelst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that empties the nodes list created by AVL_interval_find. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this doesn't frees only the list of leaf nodes returned by AVL_interval_find, but not the data itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL tree from which the list were obtained </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodelst</td><td>-&gt; the node's list created by AVL_interval_find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa52776b46e8441e55968bf19ad2b503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa52776b46e8441e55968bf19ad2b503">&#9670;&nbsp;</a></span>AVL_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVL_bst* AVL_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions returns a new AVL_bst on the heap. </p>

</div>
</div>
<a id="a77b92bbf8fc48d0a3f0ab7611e3608f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b92bbf8fc48d0a3f0ab7611e3608f7">&#9670;&nbsp;</a></span>AVL_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_delete </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that deletes the data with the given key in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL tree from which the data will be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>-&gt; the key of the data to be removed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>-&gt; a void ** to return the data as an output parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_EMPTY_TREE_ERR</td><td>if the tree is empty </td></tr>
    <tr><td class="paramname">AVL_DELETE_NON_EXISTENT_KEY_ERR</td><td>if the given key does not exist in the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef4ea630e4b9a4319d047c3bf3c1cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4ea630e4b9a4319d047c3bf3c1cd38">&#9670;&nbsp;</a></span>AVL_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_destroy </td>
          <td>(</td>
          <td class="paramtype">AVL_bst **restrict&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function destroys a AVL_bst allocated by AVL_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; a pointer to pointer to the tree to be destroyed (allocated by AVL_create)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_FREE_NULLPTR_ERR</td><td>if *tree is a NULL pointer </td></tr>
    <tr><td class="paramname">AVL_DESTROY_ROOT_NON_NULL</td><td>if the root of the tree is non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2c933f22384e280483ff295fb709080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c933f22384e280483ff295fb709080">&#9670;&nbsp;</a></span>AVL_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVL_bst_node* AVL_find </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for key in tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL tree to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>-&gt; the key to be searched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AVL_bst_node pointer</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if key is not on tree </td></tr>
    <tr><td class="paramname">AVL_bst_node</td><td>*node the leaf node with that key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecacbf39ee27a5d2d05f1b7e79d9f2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecacbf39ee27a5d2d05f1b7e79d9f2eb">&#9670;&nbsp;</a></span>AVL_get_data_from_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVL_get_data_from_node </td>
          <td>(</td>
          <td class="paramtype">AVL_bst_node *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the data from a leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>-&gt; the leaf node from which the data is obtained</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AVL_bst_node pointer</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL,if</td><td>node is not a leaf </td></tr>
    <tr><td class="paramname">void</td><td>*data, a void pointer to the data in *node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85948f4dd8cb66132a7ea19b71a9f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85948f4dd8cb66132a7ea19b71a9f59">&#9670;&nbsp;</a></span>AVL_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_init </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_alloc&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_free_node&#160;</td>
          <td class="paramname"><em>freenode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_free_data&#160;</td>
          <td class="paramname"><em>freedata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the AVL_bst attributes. Pass NULL to freedata if the allocations are done in stack, otherwise pass a free-like function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; an AVL tree created by AVL_create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>-&gt; a comparison function for keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>-&gt; an alloc function for tree nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freenode</td><td>-&gt; a free function for deallocation of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freedata</td><td>-&gt; a free function for deallocation of data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_COMPARE_FN_NOT_PROVIDED_ERR</td><td>if compare function has not been provided </td></tr>
    <tr><td class="paramname">AVL_ALLOC_FN_NOT_PROVIDED_ERR</td><td>if allocation function has not been provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad467c47f10fee3e944603989095bb1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad467c47f10fee3e944603989095bb1b0">&#9670;&nbsp;</a></span>AVL_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_insert </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that inserts a new data with given key in the tree. </p>
<dl class="section note"><dt>Note</dt><dd>IMPORTANT: It's advised that key and data must be pont to different locations in memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL tree on which to insert the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>-&gt; the key of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>-&gt; the data itself as a void pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_MAX_HEIGHT_ERR</td><td>if the tree reaches the maximum permitted height </td></tr>
    <tr><td class="paramname">AVL_DISTINCT_KEY_ERR</td><td>if trying same key insertion (if AVL_ONLY_DISTINCT_KEYS is defined) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab099c2a1c5b8706a24a2504775df1c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab099c2a1c5b8706a24a2504775df1c7f">&#9670;&nbsp;</a></span>AVL_interval_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVL_bst_node* AVL_interval_find </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for a key interval [a, b[. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL tree to be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>-&gt; lower limit of interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>-&gt; upper limit of interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ABL_bst_node pointer</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if the interval does not exist in the tree's keys </td></tr>
    <tr><td class="paramname">AVL_bst_node</td><td>*list, a list of AVL tree nodes with the interval [a, b[. If one of the limits is out of range in the tree's keys, it returns [a, &lt;max key="" on="" tree&gt;=""&gt;] or [&lt;min key="" on="" tree&gt;=""&gt;, b). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8714e1bcc93e3d015f658da9248b6484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8714e1bcc93e3d015f658da9248b6484">&#9670;&nbsp;</a></span>AVL_process_node_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL_process_node_list </td>
          <td>(</td>
          <td class="paramtype">AVL_bst_node *&#160;</td>
          <td class="paramname"><em>nodelst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_map&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that processes the node list created by AVL_interval_find. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodelst</td><td>-&gt; a linked list from AVL_bst_node's created by AVL_interval_find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapfn</td><td>-&gt; a mapping function to map the nodes of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae12c4e1787742f360b9626a2c95f5722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12c4e1787742f360b9626a2c95f5722">&#9670;&nbsp;</a></span>AVL_traverse_preorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVL_traverse_preorder </td>
          <td>(</td>
          <td class="paramtype">AVL_bst *restrict&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVL_map&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function the traverses the tree applying mapfn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>-&gt; the AVL_bst tree to be traversed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapfn</td><td>-&gt; the mapping function to be applied over each node of tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AVL_SUCCESS</td><td>if successfull </td></tr>
    <tr><td class="paramname">AVL_EMPTY_TREE_ERR</td><td>if the tree is empty </td></tr>
    <tr><td class="paramname">AVL_MAX_HEIGHT_ERR</td><td>if the height of the tree is greater than the permitted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
